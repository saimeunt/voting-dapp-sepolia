import { loadFixture } from '@nomicfoundation/hardhat-network-helpers';
import { expect } from 'chai';
import { ethers } from 'hardhat';
import { Log } from 'ethers';

import { Voting } from '../typechain-types';
import { WorkflowStatuses as WorkflowStatus } from '../lib/types';

// helper functions to transform tuple-enabled types (generated by typechain/ethers) into plain
// objects, easier to compare using expect object-related methods (deep.equal/include)
const rawVoterToVoter = ({
  isRegistered,
  hasVoted,
  votedProposalId,
}: Voting.VoterStructOutput) => ({
  isRegistered,
  hasVoted,
  votedProposalId,
});

const rawProposalToProposal = ({ description, voteCount }: Voting.ProposalStructOutput) => ({
  description,
  voteCount,
});

describe('Voting', () => {
  // Voting contract being a state machine, we provide fixtures to advance the SM into the required
  // "standard" state before each test, this is an alternative pattern to beforeEach context
  const deployContractAndSetVariablesFixture = async () => {
    const factory = await ethers.getContractFactory('Voting');
    const contract = await factory.deploy();
    const [signer1, signer2, signer3] = await ethers.getSigners();
    return { contract, signer1, signer2, signer3 };
  };
  const startProposalsRegisteringFixture = async () => {
    const { contract, signer1, signer2, signer3 } = await loadFixture(
      deployContractAndSetVariablesFixture,
    );
    await Promise.all([contract.addVoter(signer2.address), contract.addVoter(signer3.address)]);
    return { contract, signer1, signer2, signer3 };
  };
  const addProposalFixture = async () => {
    const { contract, signer1, signer2, signer3 } = await loadFixture(
      startProposalsRegisteringFixture,
    );
    await contract.startProposalsRegistering();
    return { contract, signer1, signer2, signer3 };
  };
  const endProposalsRegisteringFixture = async () => {
    const { contract, signer1, signer2, signer3 } = await loadFixture(addProposalFixture);
    await Promise.all([
      contract.connect(signer2).addProposal('proposal1'),
      contract.connect(signer3).addProposal('proposal2'),
    ]);
    return { contract, signer1, signer2, signer3 };
  };
  const startVotingSessionFixture = async () => {
    const { contract, signer1, signer2, signer3 } = await loadFixture(
      endProposalsRegisteringFixture,
    );
    await contract.endProposalsRegistering();
    return { contract, signer1, signer2, signer3 };
  };
  const voteFixture = async () => {
    const { contract, signer1, signer2, signer3 } = await loadFixture(startVotingSessionFixture);
    await contract.startVotingSession();
    return { contract, signer1, signer2, signer3 };
  };
  const endVotingSessionFixture = async () => {
    const { contract, signer1, signer2, signer3 } = await loadFixture(voteFixture);
    await Promise.all([contract.connect(signer2).setVote(1), contract.connect(signer3).setVote(1)]);
    return { contract, signer1, signer2, signer3 };
  };
  // tests are grouped by functions and each function is unit tested to reach 100% coverage
  describe('addVoter', () => {
    it('should revert if not called by owner', async () => {
      const { contract, signer2 } = await loadFixture(deployContractAndSetVariablesFixture);
      await expect(contract.connect(signer2).addVoter(signer2.address)).to.be.revertedWith(
        'Ownable: caller is not the owner',
      );
    });
    it('should revert if status is not RegisteringVoters', async () => {
      const { contract, signer2 } = await loadFixture(deployContractAndSetVariablesFixture);
      await contract.startProposalsRegistering();
      await expect(contract.addVoter(signer2.address)).to.be.revertedWith(
        'Voters registration is not open yet',
      );
    });
    it('should revert if voter is already registered', async () => {
      const { contract, signer2 } = await loadFixture(deployContractAndSetVariablesFixture);
      await contract.addVoter(signer2.address);
      await expect(contract.addVoter(signer2.address)).to.be.revertedWith('Already registered');
    });
    it('should register a single voter', async () => {
      const { contract, signer2 } = await loadFixture(deployContractAndSetVariablesFixture);
      await contract.addVoter(signer2.address);
      const rawVoter = await contract.connect(signer2).getVoter(signer2.address);
      expect(rawVoterToVoter(rawVoter).isRegistered).be.true;
    });
    it('should add multiple voters', async () => {
      const { contract, signer2, signer3 } = await loadFixture(
        deployContractAndSetVariablesFixture,
      );
      await Promise.all([contract.addVoter(signer2.address), contract.addVoter(signer3.address)]);
      const [rawVoter1, rawVoter2] = await Promise.all([
        contract.connect(signer2).getVoter(signer2.address),
        contract.connect(signer3).getVoter(signer3.address),
      ]);
      const registeredVoter = {
        isRegistered: true,
        hasVoted: false,
        votedProposalId: BigInt(0),
      };
      expect(rawVoterToVoter(rawVoter1)).to.deep.equal(registeredVoter);
      expect(rawVoterToVoter(rawVoter2)).to.deep.equal(registeredVoter);
    });
    it('should emit VoterRegistered', async () => {
      const { contract, signer2 } = await loadFixture(deployContractAndSetVariablesFixture);
      await expect(contract.addVoter(signer2.address))
        .to.emit(contract, 'VoterRegistered')
        .withArgs(signer2.address);
    });
  });
  describe('getVoter', () => {
    it('should revert if not called by registered voter', async () => {
      const { contract, signer1 } = await loadFixture(deployContractAndSetVariablesFixture);
      await expect(contract.getVoter(signer1.address)).to.be.revertedWith("You're not a voter");
    });
    it('should return a voter', async () => {
      const { contract, signer2 } = await loadFixture(startProposalsRegisteringFixture);
      const rawVoter = await contract.connect(signer2).getVoter(signer2.address);
      expect(rawVoterToVoter(rawVoter)).to.deep.equal({
        isRegistered: true,
        hasVoted: false,
        votedProposalId: BigInt(0),
      });
    });
  });
  describe('startProposalsRegistering', () => {
    it('should revert if not called by owner', async () => {
      const { contract, signer2 } = await loadFixture(startProposalsRegisteringFixture);
      await expect(contract.connect(signer2).startProposalsRegistering()).to.be.revertedWith(
        'Ownable: caller is not the owner',
      );
    });
    it('should revert if status is not RegisteringVoters', async () => {
      const { contract } = await loadFixture(startProposalsRegisteringFixture);
      await contract.startProposalsRegistering();
      await expect(contract.startProposalsRegistering()).to.be.revertedWith(
        'Registering proposals cant be started now',
      );
    });
    it('should change status to ProposalsRegistrationStarted', async () => {
      const { contract } = await loadFixture(startProposalsRegisteringFixture);
      await contract.startProposalsRegistering();
      const workflowStatus = await contract.workflowStatus();
      expect(workflowStatus).to.equal(WorkflowStatus.ProposalsRegistrationStarted);
    });
    it('should add the GENESIS proposal', async () => {
      const { contract, signer2 } = await loadFixture(startProposalsRegisteringFixture);
      await contract.startProposalsRegistering();
      const rawProposal = await contract.connect(signer2).getOneProposal(0);
      expect(rawProposalToProposal(rawProposal)).to.deep.equal({
        description: 'GENESIS',
        voteCount: BigInt(0),
      });
    });
    it('should emit WorkflowStatusChange', async () => {
      const { contract } = await loadFixture(startProposalsRegisteringFixture);
      await expect(contract.startProposalsRegistering())
        .to.emit(contract, 'WorkflowStatusChange')
        .withArgs(WorkflowStatus.RegisteringVoters, WorkflowStatus.ProposalsRegistrationStarted);
    });
  });
  describe('addProposal', () => {
    it('should revert if not called by registered voter', async () => {
      const { contract } = await loadFixture(addProposalFixture);
      await expect(contract.addProposal('proposal1')).to.be.revertedWith("You're not a voter");
    });
    it('should revert if status is not ProposalsRegistrationStarted', async () => {
      const { contract, signer2 } = await loadFixture(deployContractAndSetVariablesFixture);
      await contract.addVoter(signer2.address);
      await expect(contract.connect(signer2).addProposal('proposal1')).to.be.revertedWith(
        'Proposals are not allowed yet',
      );
    });
    it('should revert if registering an empty proposal', async () => {
      const { contract, signer2 } = await loadFixture(addProposalFixture);
      await expect(contract.connect(signer2).addProposal('')).to.be.revertedWith(
        'Vous ne pouvez pas ne rien proposer',
      );
    });
    it('should add a single proposal', async () => {
      const { contract, signer2 } = await loadFixture(addProposalFixture);
      const tx = await contract.connect(signer2).addProposal('proposal1');
      const receipt = await tx.wait();
      const [event] = receipt?.logs as Log[];
      const rawProposal = await contract.connect(signer2).getOneProposal(event.data);
      expect(rawProposalToProposal(rawProposal).description).to.equal('proposal1');
    });
    it('should add multiple proposals', async () => {
      const { contract, signer2, signer3 } = await loadFixture(addProposalFixture);
      const [tx1, tx2] = await Promise.all([
        contract.connect(signer2).addProposal('proposal1'),
        contract.connect(signer3).addProposal('proposal2'),
      ]);
      const [receipt1, receipt2] = await Promise.all([tx1.wait(), tx2.wait()]);
      const [event1] = receipt1?.logs as Log[];
      const [event2] = receipt2?.logs as Log[];
      const [rawProposal1, rawProposal2] = await Promise.all([
        contract.connect(signer2).getOneProposal(event1.data),
        contract.connect(signer3).getOneProposal(event2.data),
      ]);
      expect(rawProposalToProposal(rawProposal1)).to.deep.equal({
        description: 'proposal1',
        voteCount: BigInt(0),
      });
      expect(rawProposalToProposal(rawProposal2)).to.deep.equal({
        description: 'proposal2',
        voteCount: BigInt(0),
      });
    });
    it('should emit ProposalRegistered', async () => {
      const { contract, signer2 } = await loadFixture(addProposalFixture);
      await expect(contract.connect(signer2).addProposal('proposal1'))
        .to.emit(contract, 'ProposalRegistered')
        .withArgs(1);
    });
  });
  describe('getOneProposal', () => {
    it('should revert if not called by registered voter', async () => {
      const { contract } = await loadFixture(deployContractAndSetVariablesFixture);
      await expect(contract.getOneProposal(0)).to.be.revertedWith("You're not a voter");
    });
    it('should revert when trying to access an invalid proposal', async () => {
      const { contract, signer2 } = await loadFixture(endProposalsRegisteringFixture);
      await expect(contract.connect(signer2).getOneProposal(3)).to.revertedWithPanic(50);
    });
    it('should return a proposal', async () => {
      const { contract, signer2 } = await loadFixture(endProposalsRegisteringFixture);
      const rawProposal = await contract.connect(signer2).getOneProposal(1);
      expect(rawProposalToProposal(rawProposal)).to.deep.equal({
        description: 'proposal1',
        voteCount: BigInt(0),
      });
    });
  });
  describe('endProposalsRegistering', () => {
    it('should revert if not called by owner', async () => {
      const { contract, signer2 } = await loadFixture(endProposalsRegisteringFixture);
      await expect(contract.connect(signer2).endProposalsRegistering()).to.be.revertedWith(
        'Ownable: caller is not the owner',
      );
    });
    it('should revert if status is not ProposalsRegistrationStarted', async () => {
      const { contract } = await loadFixture(deployContractAndSetVariablesFixture);
      await expect(contract.endProposalsRegistering()).to.be.revertedWith(
        'Registering proposals havent started yet',
      );
    });
    it('should change status to ProposalsRegistrationEnded', async () => {
      const { contract } = await loadFixture(endProposalsRegisteringFixture);
      await contract.endProposalsRegistering();
      const workflowStatus = await contract.workflowStatus();
      expect(workflowStatus).to.equal(WorkflowStatus.ProposalsRegistrationEnded);
    });
    it('should emit WorkflowStatusChange', async () => {
      const { contract } = await loadFixture(endProposalsRegisteringFixture);
      await expect(contract.endProposalsRegistering())
        .to.emit(contract, 'WorkflowStatusChange')
        .withArgs(
          WorkflowStatus.ProposalsRegistrationStarted,
          WorkflowStatus.ProposalsRegistrationEnded,
        );
    });
  });
  describe('startVotingSession', () => {
    it('should revert if not called by owner', async () => {
      const { contract, signer2 } = await loadFixture(startVotingSessionFixture);
      await expect(contract.connect(signer2).startVotingSession()).to.be.revertedWith(
        'Ownable: caller is not the owner',
      );
    });
    it('should revert if status is not ProposalsRegistrationEnded', async () => {
      const { contract } = await loadFixture(deployContractAndSetVariablesFixture);
      await expect(contract.startVotingSession()).to.be.revertedWith(
        'Registering proposals phase is not finished',
      );
    });
    it('should change status to VotingSessionStarted', async () => {
      const { contract } = await loadFixture(startVotingSessionFixture);
      await contract.startVotingSession();
      const workflowStatus = await contract.workflowStatus();
      expect(workflowStatus).to.equal(WorkflowStatus.VotingSessionStarted);
    });
    it('should emit WorkflowStatusChange', async () => {
      const { contract } = await loadFixture(startVotingSessionFixture);
      await expect(contract.startVotingSession())
        .to.emit(contract, 'WorkflowStatusChange')
        .withArgs(WorkflowStatus.ProposalsRegistrationEnded, WorkflowStatus.VotingSessionStarted);
    });
  });
  describe('setVote', () => {
    it('should revert if not called by registered voter', async () => {
      const { contract } = await loadFixture(voteFixture);
      await expect(contract.setVote(1)).to.be.revertedWith("You're not a voter");
    });
    it('should revert if status is not VotingSessionStarted', async () => {
      const { contract, signer2 } = await loadFixture(deployContractAndSetVariablesFixture);
      await contract.addVoter(signer2.address);
      await expect(contract.connect(signer2).setVote(1)).to.be.revertedWith(
        'Voting session havent started yet',
      );
    });
    it('should revert if voter has already voted', async () => {
      const { contract, signer2 } = await loadFixture(voteFixture);
      await contract.connect(signer2).setVote(1);
      await expect(contract.connect(signer2).setVote(1)).to.be.revertedWith(
        'You have already voted',
      );
    });
    it('should revert if voting on a non existing proposal', async () => {
      const { contract, signer2 } = await loadFixture(voteFixture);
      await expect(contract.connect(signer2).setVote(3)).to.be.revertedWith('Proposal not found');
    });
    it('should register a vote', async () => {
      const { contract, signer2 } = await loadFixture(voteFixture);
      await contract.connect(signer2).setVote(1);
      const rawVoter = await contract.connect(signer2).getVoter(signer2.address);
      expect(rawVoterToVoter(rawVoter)).to.include({
        hasVoted: true,
        votedProposalId: BigInt(1),
      });
    });
    it('should increment the proposal vote count', async () => {
      const { contract, signer2 } = await loadFixture(voteFixture);
      const rawProposalBeforeVote = await contract.connect(signer2).getOneProposal(1);
      await contract.connect(signer2).setVote(1);
      const rawProposalAfterVote = await contract.connect(signer2).getOneProposal(1);
      expect(rawProposalToProposal(rawProposalAfterVote).voteCount).to.equal(
        rawProposalToProposal(rawProposalBeforeVote).voteCount + BigInt(1),
      );
    });
    it('should emit Voted', async () => {
      const { contract, signer2 } = await loadFixture(voteFixture);
      await expect(contract.connect(signer2).setVote(1))
        .to.emit(contract, 'Voted')
        .withArgs(signer2.address, 1);
    });
  });
  describe('endVotingSession', () => {
    it('should revert if not called by owner', async () => {
      const { contract, signer2 } = await loadFixture(endVotingSessionFixture);
      await expect(contract.connect(signer2).endVotingSession()).to.be.revertedWith(
        'Ownable: caller is not the owner',
      );
    });
    it('should revert if status is not VotingSessionStarted', async () => {
      const { contract } = await loadFixture(deployContractAndSetVariablesFixture);
      await expect(contract.endVotingSession()).to.be.revertedWith(
        'Voting session havent started yet',
      );
    });
    it('should change status to VotingSessionEnded', async () => {
      const { contract } = await loadFixture(endVotingSessionFixture);
      await contract.endVotingSession();
      const workflowStatus = await contract.workflowStatus();
      expect(workflowStatus).to.equal(WorkflowStatus.VotingSessionEnded);
    });
    it('should emit WorkflowStatusChange', async () => {
      const { contract } = await loadFixture(endVotingSessionFixture);
      await expect(contract.endVotingSession())
        .to.emit(contract, 'WorkflowStatusChange')
        .withArgs(WorkflowStatus.VotingSessionStarted, WorkflowStatus.VotingSessionEnded);
    });
    it('should compute the winning proposal (1)', async () => {
      const { contract } = await loadFixture(endVotingSessionFixture);
      await contract.endVotingSession();
      const winningProposalID = await contract.winningProposalID();
      expect(winningProposalID).to.equal(1);
    });
    it('should compute the winning proposal (2)', async () => {
      const { contract, signer2, signer3 } = await loadFixture(voteFixture);
      await Promise.all([
        contract.connect(signer2).setVote(2),
        contract.connect(signer3).setVote(2),
      ]);
      await contract.endVotingSession();
      const winningProposalID = await contract.winningProposalID();
      expect(winningProposalID).to.equal(2);
    });
    it('should designate the genesis proposal as winner if no votes are registered', async () => {
      const { contract } = await loadFixture(voteFixture);
      await contract.endVotingSession();
      const winningProposalID = await contract.winningProposalID();
      expect(winningProposalID).to.equal(0);
    });
    it('should fail to register a tie (winner is the first with highest vote count)', async () => {
      const { contract, signer2, signer3 } = await loadFixture(voteFixture);
      await contract.connect(signer2).setVote(1);
      await contract.connect(signer3).setVote(2);
      await contract.endVotingSession();
      const winningProposalID = await contract.winningProposalID();
      expect(winningProposalID).to.equal(1);
    });
  });
});
